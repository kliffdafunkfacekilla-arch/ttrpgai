from fastapi import Depends, FastAPI, HTTPException
from sqlalchemy.orm import Session
from typing import List, Dict, Any

# Import all our other files
from . import crud, models, schemas, services
from .database import SessionLocal, engine

# This creates the FastAPI application instance
app = FastAPI(
    title="Story Engine",
    description="Manages campaign state, quests, and orchestrates other services."
)

# --- Dependency ---
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# --- API Endpoints ---

@app.get("/")
def read_root():
    return {"status": "Story Engine is running."}

# --- 1. MEMORY Endpoints (For the AI DM to save/load state) ---

@app.post("/v1/campaigns/", response_model=schemas.Campaign, status_code=201)
def create_campaign(
    campaign: schemas.CampaignCreate, db: Session = Depends(get_db)
):
    """(AI DM) Create a new campaign at the start of a game."""
    return crud.create_campaign(db=db, campaign=campaign)

@app.get("/v1/campaigns/{campaign_id}", response_model=schemas.Campaign)
def read_campaign(campaign_id: int, db: Session = Depends(get_db)):
    """(AI DM) Get campaign info and all its active quests."""
    db_campaign = crud.get_campaign(db, campaign_id=campaign_id)
    if db_campaign is None:
        raise HTTPException(status_code=404, detail="Campaign not found")
    return db_campaign

@app.post("/v1/quests/", response_model=schemas.ActiveQuest, status_code=201)
def create_quest(
    quest: schemas.ActiveQuestCreate, db: Session = Depends(get_db)
):
    """(AI DM) Add a new quest (generated by the AI) to the log."""
    return crud.create_quest(db=db, quest=quest)

@app.put("/v1/quests/{quest_id}", response_model=schemas.ActiveQuest)
def update_quest(
    quest_id: int,
    updates: schemas.ActiveQuestUpdate,
    db: Session = Depends(get_db)
):
    """(AI DM) Update a quest's status (e.g., 'failed') or advance its step."""
    db_quest = crud.update_quest(db, quest_id, updates)
    if db_quest is None:
        raise HTTPException(status_code=404, detail="Quest not found")
    return db_quest

@app.get("/v1/quests/campaign/{campaign_id}", response_model=List[schemas.ActiveQuest])
def read_quests_for_campaign(campaign_id: int, db: Session = Depends(get_db)):
    """(AI DM) Get all quests for a campaign."""
    return crud.get_quests_for_campaign(db, campaign_id)

@app.post("/v1/flags/", response_model=schemas.StoryFlag)
def set_story_flag(
    flag: schemas.StoryFlagBase, db: Session = Depends(get_db)
):
    """
    (AI DM) Set a story flag (e.g., 'player_killed_npc').
    This will create the flag if it doesn't exist or update it if it does.
    """
    return crud.set_flag(db=db, flag=flag)

@app.get("/v1/flags/{flag_name}", response_model=schemas.StoryFlag)
def read_story_flag(flag_name: str, db: Session = Depends(get_db)):
    """(AI DM) Check the value of a specific story flag."""
    db_flag = crud.get_flag(db, flag_name)
    if db_flag is None:
        raise HTTPException(status_code=404, detail="Flag not found")
    return db_flag

# --- 2. ORCHESTRATION Endpoints (For the AI DM to take action) ---

@app.post("/v1/actions/spawn_npc", response_model=Dict)
async def action_spawn_npc(spawn_request: schemas.OrchestrationSpawnNpc):
    """(AI DM) High-level command to spawn an NPC in the world_engine."""
    try:
        response = await services.spawn_npc_in_world(spawn_request)
        return response
    except Exception as e:
        raise HTTPException(status_code=503, detail=f"Error calling world_engine: {e}")

@app.post("/v1/actions/spawn_item", response_model=Dict)
async def action_spawn_item(spawn_request: schemas.OrchestrationSpawnItem):
    """(AI DM) High-level command to spawn an item in the world_engine."""
    try:
        response = await services.spawn_item_in_world(spawn_request)
        return response
    except Exception as e:
        raise HTTPException(status_code=503, detail=f"Error calling world_engine: {e}")

@app.get("/v1/context/character/{char_id}",
    response_model=schemas.OrchestrationCharacterContext)
async def get_character_context(char_id: int):
    """(AI DM) Get a full status snapshot from the character_engine."""
    try:
        return await services.get_character_context(char_id)
    except Exception as e:
        raise HTTPException(status_code=503, detail=f"Error calling character_engine: {e}")

@app.get("/v1/context/location/{location_id}",
    response_model=schemas.OrchestrationWorldContext)
async def get_location_context(location_id: int):
    """(AI DM) Get a full status snapshot from the world_engine."""
    try:
        return await services.get_world_location_context(location_id)
    except Exception as e:
        raise HTTPException(status_code=503, detail=f"Error calling world_engine: {e}")
