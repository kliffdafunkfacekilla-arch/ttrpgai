from fastapi import Depends, FastAPI, HTTPException
from sqlalchemy.orm import Session
from typing import List, Dict, Any
import logging

# Import all our other files
from . import crud, models, schemas, services, combat_handler, interaction_handler # ADD interaction_handler
from .database import SessionLocal, engine

# This creates the FastAPI application instance
app = FastAPI(
    title="Story Engine",
    description="Manages campaign state, quests, and orchestrates other services."
)

logger = logging.getLogger("uvicorn.error")

# --- Dependency ---
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# --- API Endpoints ---

@app.get("/")
def read_root():
    return {"status": "Story Engine is running."}

# --- 1. MEMORY Endpoints (For the AI DM to save/load state) ---

@app.post("/v1/campaigns/", response_model=schemas.Campaign, status_code=201)
def create_campaign(
    campaign: schemas.CampaignCreate, db: Session = Depends(get_db)
):
    """(AI DM) Create a new campaign at the start of a game."""
    return crud.create_campaign(db=db, campaign=campaign)

@app.get("/v1/campaigns/{campaign_id}", response_model=schemas.Campaign)
def read_campaign(campaign_id: int, db: Session = Depends(get_db)):
    """(AI DM) Get campaign info and all its active quests."""
    db_campaign = crud.get_campaign(db, campaign_id=campaign_id)
    if db_campaign is None:
        raise HTTPException(status_code=404, detail="Campaign not found")
    return db_campaign

@app.post("/v1/quests/", response_model=schemas.ActiveQuest, status_code=201)
def create_quest(
    quest: schemas.ActiveQuestCreate, db: Session = Depends(get_db)
):
    """(AI DM) Add a new quest (generated by the AI) to the log."""
    return crud.create_quest(db=db, quest=quest)

@app.put("/v1/quests/{quest_id}", response_model=schemas.ActiveQuest)
def update_quest(
    quest_id: int,
    updates: schemas.ActiveQuestUpdate,
    db: Session = Depends(get_db)
):
    """(AI DM) Update a quest's status (e.g., 'failed') or advance its step."""
    db_quest = crud.update_quest(db, quest_id, updates)
    if db_quest is None:
        raise HTTPException(status_code=404, detail="Quest not found")
    return db_quest

@app.get("/v1/quests/campaign/{campaign_id}", response_model=List[schemas.ActiveQuest])
def read_quests_for_campaign(campaign_id: int, db: Session = Depends(get_db)):
    """(AI DM) Get all quests for a campaign."""
    return crud.get_quests_for_campaign(db, campaign_id)

@app.post("/v1/flags/", response_model=schemas.StoryFlag)
def set_story_flag(
    flag: schemas.StoryFlagBase, db: Session = Depends(get_db)
):
    """
    (AI DM) Set a story flag (e.g., 'player_killed_npc').
    This will create the flag if it doesn't exist or update it if it does.
    """
    return crud.set_flag(db=db, flag=flag)

@app.get("/v1/flags/{flag_name}", response_model=schemas.StoryFlag)
def read_story_flag(flag_name: str, db: Session = Depends(get_db)):
    """(AI DM) Check the value of a specific story flag."""
    db_flag = crud.get_flag(db, flag_name)
    if db_flag is None:
        raise HTTPException(status_code=404, detail="Flag not found")
    return db_flag

# --- 2. ORCHESTRATION Endpoints (For the AI DM to take action) ---

@app.post("/v1/actions/spawn_npc", response_model=Dict)
async def action_spawn_npc(spawn_request: schemas.OrchestrationSpawnNpc):
    """(AI DM) High-level command to spawn an NPC in the world_engine."""
    try:
        response = await services.spawn_npc_in_world(spawn_request)
        return response
    except Exception as e:
        raise HTTPException(status_code=503, detail=f"Error calling world_engine: {e}")

@app.post("/v1/actions/spawn_item", response_model=Dict)
async def action_spawn_item(spawn_request: schemas.OrchestrationSpawnItem):
    """(AI DM) High-level command to spawn an item in the world_engine."""
    try:
        response = await services.spawn_item_in_world(spawn_request)
        return response
    except Exception as e:
        raise HTTPException(status_code=503, detail=f"Error calling world_engine: {e}")

@app.get("/v1/context/character/{char_id}",
    response_model=schemas.OrchestrationCharacterContext)
async def get_character_context(char_id: int):
    """(AI DM) Get a full status snapshot from the character_engine."""
    try:
        return await services.get_character_context(char_id)
    except Exception as e:
        raise HTTPException(status_code=503, detail=f"Error calling character_engine: {e}")

@app.get("/v1/context/location/{location_id}",
    response_model=schemas.OrchestrationWorldContext)
async def get_location_context(location_id: int):
    """(AI DM) Get a full status snapshot from the world_engine."""
    try:
        return await services.get_world_location_context(location_id)
    except Exception as e:
        raise HTTPException(status_code=503, detail=f"Error calling world_engine: {e}")

# ADD THIS ENDPOINT for starting combat
@app.post("/v1/combat/start", response_model=schemas.CombatEncounter, status_code=201, tags=["Combat Orchestration"])
async def api_start_new_combat(start_request: schemas.CombatStartRequest, db: Session = Depends(get_db)):
    """
    (AI DM) Starts a new combat encounter:
    - Spawns requested NPCs via world_engine.
    - Rolls initiative for players and NPCs via rules_engine.
    - Creates combat state records in story_engine DB.
    Returns the initial state of the combat encounter.
    """
    logger.info(f"Received request to start combat at location {start_request.location_id}")
    try:
        # Call the combat handler function to do the work
        combat_state = await combat_handler.start_combat(db, start_request)
        if combat_state is None: # Should be handled by exceptions in handler, but belts-and-suspenders
             raise HTTPException(status_code=500, detail="Combat handler failed to return state.")
        logger.info(f"Combat started with ID: {combat_state.id}")
        # The combat_state object from DB should match the response_model
        return combat_state
    except HTTPException as he:
         # Re-raise HTTPExceptions raised by services or the handler
         logger.error(f"HTTPException during combat start: {he.detail}")
         raise he
    except Exception as e:
        logger.exception(f"Unexpected error starting combat: {e}") # Log full traceback
        raise HTTPException(status_code=500, detail=f"Internal server error starting combat: {str(e)}")


@app.post("/v1/combat/{combat_id}/player_action", response_model=Dict, tags=["Combat Orchestration"])
async def handle_player_combat_action(
    combat_id: int,
    action_request: schemas.PlayerActionRequest,
    db: Session = Depends(get_db)
    # TODO: Add way to identify player_id (e.g., from auth token)
):
    """Receives and processes a player's action during their turn."""
    logger.info(f"Received player action for combat {combat_id}: {action_request.dict()}")

    # TODO: Verify it's actually this player's turn based on combat state
    player_id = "player_1" # Placeholder - get actual player ID

    try:
        # Call the main execution logic
        action_result = await combat_handler.execute_combat_action(
            db, combat_id, player_id, action_request
        )

        logger.info(f"Action result: {action_result.get('message')}")
        # Return the detailed result
        return action_result

    except HTTPException as he:
         logger.error(f"HTTPException during player action: {he.detail}")
         raise he
    except Exception as e:
         logger.exception(f"Unexpected error during player action: {e}")
         raise HTTPException(status_code=500, detail=f"Internal server error processing player action: {str(e)}")

# --- ADD THIS ENDPOINT for Interactions ---
@app.post("/v1/actions/interact", response_model=schemas.InteractionResponse, tags=["Player Actions"])
async def handle_player_interaction(
    interaction_request: schemas.InteractionRequest,
    # db: Session = Depends(get_db) # May need DB later for complex interactions
):
    """
    (Player Interface) Processes player interactions with annotated objects in the world.
    Fetches location state, checks annotations, and orchestrates updates.
    """
    logger.info(f"Received interaction request: {interaction_request.dict()}")
    try:
        # Call the handler function to do the work
        result = await interaction_handler.handle_interaction(interaction_request)
        return result
    except HTTPException as he:
        # Re-raise HTTPExceptions raised by services or the handler
        logger.error(f"HTTPException during interaction: {he.detail}")
        raise he
    except Exception as e:
        logger.exception(f"Unexpected error handling interaction: {e}")
        raise HTTPException(status_code=500, detail=f"Internal server error handling interaction: {str(e)}")
